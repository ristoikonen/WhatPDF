@page "/PDF"
@rendermode InteractiveServer
@using static ComponentEnums.PDFParams
@using MudBlazor

<PageTitle>PDF</PageTitle>

<h1>PDF</h1>

<EditForm Model="_model">
    <InputRadioGroup @bind-Value="@_model.SelectedManufacturer">
        Manufacturer:
        <br>
        @foreach (var manufacturer in Manufacturers)
        {
            <InputRadio Value="manufacturer" />
            @manufacturer
            <br>
        }
    </InputRadioGroup>
    <InputCheckbox @bind-Value="_model.ReadImages" />
    <label>ReadImages</label>

    <InputCheckbox @bind-Value="_model.Compress" />
    <label>Compress (LZ)</label>

    <InputCheckbox @bind-Value="_model.RemoveStopwords" />
    <label>Remove Stopwords</label>

    <button type="submit">Submit</button>
</EditForm>

<MudText>
    @_progress_msg
</MudText>
<MudProgressLinear Value="@progress_value" Rounded="true" Size="Size.Large" Color="Color.Info" BufferValue="@buffer_progress_value"/>






<MudTimeline>
    <MudTimelineItem>
        <ItemContent>
            <MudText>Open PDF</MudText>
            <MudProgressLinear Value="@progress_value1" Rounded="true" Size="Size.Medium" Color="Color.Primary" />
        </ItemContent>
    </MudTimelineItem>
    <MudTimelineItem Active="@showitem">
        <MudText Align="Align.End">Read PDF</MudText>
        <MudProgressLinear Value="@progress_value2" Rounded="true" Size="Size.Medium" Color="Color.Info" />
    </MudTimelineItem>
    <MudTimelineItem Color="Color.Primary">
        <MudText>Read text</MudText>
        <MudProgressLinear Value="@progress_value3" Rounded="true" Size="Size.Medium" Color="Color.Secondary" />
    </MudTimelineItem>
</MudTimeline>


<div>Upload PDF:</div>

<InputFile OnChange="HandleFileSelectedAsync" />

<div>PDF</div>

@((MarkupString)textchunk.Replace(Environment.NewLine, "<br />"))



@code {

    bool submitted = false;
    private bool _disposed;
    private bool showitem = false;
    
    [SupplyParameterFromForm]
    private string? Name { get; set; }
    private string _progress_msg = "";
    private int progress_value = 0;
    private int progress_value1 = 0;
    private int progress_value2 = 0;
    private int progress_value3 = 0;
    private int buffer_progress_value = 0;
    private double _doubleValue;

    private void Submit() => submitted = true;


    // [Range(typeof(PDFParams), nameof(PDFParams),
    // nameof(Manufacturer.VirginGalactic), ErrorMessage = "Pick a manufacturer.")]
    // public Manufacturer Manufacturer { get; set; } = Manufacturer.Unknown;

    List<String> Manufacturers = new List<string> { "Remove stopwords", "Compress(LZ)", "Read Images" };

    FormModel _model = new FormModel();


    class FormModel
    {
        public String SelectedManufacturer { get; set; } = "Read Images";
        public bool IsChecked { get; set; }
        public bool ReadImages { get; set; } = true;
        public bool RemoveStopwords { get; set; } = false;
        public bool Compress { get; set; } = true;
    }

    private string textchunk = "";

    private void SetProgressValues(bool add, int val, string msg)
    {
        const int max = 100;
        if(add)
        {
            progress_value += max >= (progress_value + val) ? val : 0 ;
            buffer_progress_value = progress_value + 10 <= max ? progress_value + 10 : max;
        }
        else
        {
            progress_value = max >= (progress_value + val) ? val : 0;
            buffer_progress_value = progress_value + 10 <= max ? progress_value + 10 : max;
        }
        _progress_msg = msg ?? "";  //!string.IsNullOrWhiteSpace(msg) ? msg;
        StateHasChanged();
    }

    private void SetProgressStage(bool add, int valtotal, int val1, int val2, int val3, string msg)
    {
        const int max = 100;
        if (add)
        {
            showitem = true;
            progress_value1 += max >= (progress_value1 + val1) ? val1 : max;
            progress_value2 += max >= (progress_value2 + val2) ? val2 : max;
            progress_value3 += max >= (progress_value3 + val3) ? val3 : max;
            //progress_value += max >= (progress_value + valtotal) ? valtotal : max;
            buffer_progress_value = progress_value + 10 <= max ? progress_value + 10 : max;
        }
        else
        {
            progress_value = (max >= (progress_value + valtotal)) ? valtotal : 0;
            buffer_progress_value = (progress_value + 10 <= max) ? progress_value + 10 : max;
        }
        _progress_msg = msg ?? "";  //!string.IsNullOrWhiteSpace(msg) ? msg;
        StateHasChanged();
    }

    private async Task HandleFileSelectedAsync(InputFileChangeEventArgs e)
    {
        bool conmpress = _model.Compress;
        bool readimages = _model.ReadImages;
        bool removestopwords = _model.RemoveStopwords;

        List<string>? textblocks = new List<string>();
        var file = e.File;

        //foreach (var file in e.GetMultipleFiles())
        if (file is not null && file is IBrowserFile)
        {
            var filename = file.Name ?? "";
            _progress_msg = "Reading " + filename;
			SetProgressValues(false, 10, _progress_msg);
            SetProgressStage(true, 10, 10, 0, 0, _progress_msg);

            var buffer = new byte[file.Size];
            await Task.Delay(100);

            SetProgressValues(false, 20, _progress_msg);
            SetProgressStage(true, 20, 30, 10, 0, _progress_msg);

            using (var memoryStream = new MemoryStream())
            {
                //await using FileStream fs = new(path, FileMode.Create);
                await file.OpenReadStream(file.Size).CopyToAsync(memoryStream);
                
                SetProgressValues(false, 30, _progress_msg);
                SetProgressStage(true, 20, 30, 10, 0, _progress_msg);

                await Task.Delay(100);

                var byteArray = memoryStream.ToArray();

                Reader reader = new Reader();
                //await
                _progress_msg = "Reading " + filename;
                SetProgressValues(false, 40, _progress_msg);
                SetProgressStage(true, 20, 60, 30, 0, _progress_msg);

                await Task.Delay(100);

                var pdfdata = reader.ReadPdfData(byteArray, filename);

                SetProgressValues(false, 60, _progress_msg);
                SetProgressStage(true, 10, 100, 40, 30, _progress_msg);
                await Task.Delay(100);

                if (pdfdata is not null && pdfdata is PDFData && pdfdata.Pages is not null)
                {
                    _progress_msg = "Have data of " + filename;
					SetProgressValues(false, 90, _progress_msg);
                    SetProgressStage(true, 20, 100, 100, 30, _progress_msg);
                    await Task.Delay(100);

                    string singleString = String.Join(Environment.NewLine, pdfdata.Pages);
                    SetProgressStage(true, 20, 100, 100, 20, _progress_msg);
                    textchunk = singleString ?? "";
                }
            }

        }

        _progress_msg = "Done!";
        SetProgressValues(false, 100, _progress_msg);
        SetProgressStage(true, 100, 100, 100, 100, _progress_msg);
        await Task.Delay(100);


        // Process each file here, e.g., read its content, save to server
        // Example: Read file to a byte array
        // var buffer = new byte[file.Size];
        // await file.OpenReadStream().ReadAsync(buffer);

        // Example: Save to wwwroot/Uploads
        // var path = Path.Combine(env.WebRootPath, "uploads", file.Name);
        // await using FileStream fs = new(path, FileMode.Create);
        // await file.OpenReadStream().CopyToAsync(fs);
        //}
    }
}
